#-------------------------------------------- Get Data & Parameters ------------------------------------------------
# *********  Checked √   **********

"""
1.0 Initialization
"""
import pandas as pd
import numpy as np
pd.core.common.is_list_like = pd.api.types.is_list_like
import fix_yahoo_finance as yf
import datetime
from pandas_datareader import data as pdr      # For download data
yf.pdr_override()
import matplotlib.pyplot as plt
import scipy.optimize as opt

"""
2.0 Get Raw Data
"""
tickers = ['BSV','LQD','IGIB','SHY','IVV','PDP','IXN','IJH', 'IJR','EMB','EFA','EEM']
st = datetime.datetime(2008,1,1)
end = datetime.datetime(2015,10,31)

num = len(tickers)

try:
    ret = pd.read_csv('ret.csv',index_col=0)
    price = pd.read_csv('price.csv',index_col=0)
    ret.index = pd.to_datetime(ret.index)
    price.index = pd.to_datetime(price.index)
    print('***Data exist.***')
except:
    print('***Downloading data.***')
        # tickers = ['BSV','LQD','IGIB','SHY','IVV','PDP','IXN','IJH', 'IJR','EMB','EFA']

    price = pdr.get_data_yahoo(tickers, start=st, end=end) ["Adj Close"]
    ret = price.pct_change().dropna()
    
    #--------------SAVING DATA------------------------
    print('***Saving Data.***')
    ret.to_csv('ret.csv')
    price.to_csv('price.csv')

"""
3.0 Data Cleaning
"""
print('NaN values: \n', np.sum(price.isna(),axis=0))
print('\nMissing values: \n',np.sum(price.isnull(),axis=0))

"""
4.0 Data Analysis
"""
# 4.1 Plot All Price Data
plt.figure()
price.plot(figsize=(20,10))
plt.title('All Assets All Time Daily Price Plot',fontsize=20)
plt.xlabel('ETFs',fontsize=15)
plt.ylabel('Close Price',fontsize=15)
plt.show()
# plt.savefig('PriceOverview')

# 4.2 Plot All Returns
#fig = plt.figure(figsize=(20,10))
   
#for i in range(0,len(tickers)):
#    plt.subplot(3,4,i+1)
#    plt.plot(ret.iloc[:,i],color='#607c8e',linewidth=0.5)
#    plt.title(tickers[i], fontsize=10, style='italic')   

#fig.suptitle('Returns of ETFs',fontsize=20) 
#plt.savefig('Returns')
#plt.show()

"""
5. Properties of Data
"""
# 5.1 Mean & Volatility
mu = np.mean(ret)*252  # Annualized Mean Returns
vol = np.std(ret)*np.sqrt(252)  # Annualized Volatilities

# 5.2 Plots:
bonds = ['BSV','LQD','IGIB','SHY','EMB']
color= ['orange' if ETF in bonds else 'skyblue' for ETF in ret.columns]
plt.scatter(ret.columns, vol, color=color)
plt.title('Annualized Volatility for Stock & Bond ETFs')
plt.show()

# 5.3 Leverage Bonds
n_levg = 3
ret[bonds] *= n_levg 

# 5.4 Leveraged Mean & Volatility
mu_levg = np.mean(ret)*252  # Annualized Mean Returns(After leverage)
vol_levg = np.std(ret)*np.sqrt(252)  # Annualized Volatilities(After leverage)

plt.scatter(ret.columns, vol_levg, color=color)
plt.title('Annualized Volatility for Stock & Leveraged Bond ETFs')
plt.show()


"""
6. Cross-Assets Properties of Data
"""
# Covariance & Correlations
covMat = ret.cov()
corrMat = ret.corr()
print('\nCovariance Matrix of Portfolio: \n',covMat)
print('\nCorrelation Matrix of Portfolio: \n',corrMat)

#---------------------------------------- Rolling & Running (Yaoyun) ------------------------------------------
# *********  Checked √   **********

# cmoments: 如果从2007/12/17开始，第一个月的weight和portfolio return只有7天数据，不准确，
#           so已将数据起始日调整至2008/01/01，以一年的COV matrix作为input，第一个有效的rolling weight为2009年1月。


"""
7. Calculate Optimal Portolio Weights/Positions
"""
# 7.1 Initialize Parameters
Ndays = 252
w_BlackRock = np.matrix([0.22,0.12,0.1,0.05,0.20,0.05,0.05,0.03,0.03,0.08,0.04,0.03])


# 7.2 Get 1-Yr-Rolling Portfolio Covariance Matrices
# ------------------------------------------------------------

# All Rolling Covariance Matrices
all_covMats = ret.rolling(Ndays).cov().dropna()

# Only Get the Last 1-Yr-Cov-Mat of Every Month
month_covMats = all_covMats.groupby(pd.Grouper(freq='M',level=0)).tail(num)

# Dates where we extract Covariance Matrix for Weights Calc (Monthly)
cov_dates = np.unique(month_covMats.index.get_level_values('Date'))[:-1] # we don't need the last covariance matrix

# All Dates (Daily) (1 Yr after beginning of data)    
all_dates = ret.iloc[Ndays-1:,].index

# Where Turnover Happens (should == #s Covariance Matrix is extracted == #s Weights Calculated )
toID = np.diff(np.array(all_dates.month))!=0      
toID = pd.Series(toID, index=all_dates[1:])

# 7.3 Safty Checks
if sum(toID)!=len(cov_dates):
    print("Error! Turnover times and numbers of covariance matrices obtained don't match.")


# 7.4 Calculate Rolling Portfolio Positions & Daily Returns 
# ----------------------------------------------------------
ret1 = pd.Series()
ret2 = pd.Series()
weight = pd.DataFrame(columns = ret.columns)
risk_cont = pd.DataFrame(columns = ret.columns)
sse = pd.DataFrame(columns =['SUM Sq Error'])

k = 0 
#for i in range(0,21):
for i in range(0,len(toID)):
    date = toID.index[i]

    if toID[i]==True: # Signal for 调仓
        
        # Calculate Portfolio Weights for Current Month:
        cov_ = np.matrix(month_covMats.loc[cov_dates[k]]) # Checked √
        sigma_ = float(np.sqrt(w_BlackRock*cov_*w_BlackRock.T)) # Checked √
        w_ = risk_parity(sigma_,np.array(cov_)) # Checked √
        weight.loc[date] = w_
        
        # Double Check for Equal Risk Contribution
        risk_cont.loc[date] = cal_risk_contribution(w_,np.array(cov_))
        # Check for Mininum Sum of Squared Errors
        sse.loc[date] = cal_sum_sq_error(w_,np.array(cov_))
        
        
        k += 1
    
    # else: Everything is unchanged
    
    # Calculate Daily Returns
    ret1[date] = sum(w_*ret.loc[date]) # Risk-Parity
    ret2[date] = sum(np.squeeze(np.asarray(w_BlackRock))*ret.loc[date]) # 60/40

# 7.5 Check Results
weight
risk_cont
sse

plt.figure(figsize=(8,4))
net_value = np.cumprod(ret1+1)
net_value.plot()
net_value2 = np.cumprod(ret2+1)
#net_value2.plot()
ret3 = price.IVV[all_dates[0]:].pct_change()
net_value3 = np.cumprod(ret3+1)
net_value3.plot()


######
items = ['sharpe','annual_return','annual_vol','max_drawdown','VaR']

sharpe = [ret1.mean()/ret1.std()*np.sqrt(250),ret2.mean()/ret2.std()*np.sqrt(250)]
annual_return = [cal_ann_return(ret1),cal_ann_return(ret2)]
annual_vol = [cal_ann_vol(ret1),cal_ann_vol(ret2)]
#market_beta = [cal_market_beta(ret1),cal_market_beta(ret2)]
max_drawdown = [cal_max_drawdown(ret1),cal_max_drawdown(ret2)]
VaR = [cal_VaR(ret1,0.05),cal_VaR(ret2,0.05)]
backtest_table = pd.DataFrame([sharpe,annual_return,annual_vol,max_drawdown,VaR],\
                              index=items,columns = ['risk_parity','40-60'])
